#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright 2012 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
1. The first mode is used to generate and authorize an OAuth2 token, the
first step in logging in via OAuth2.

  oauth2 --client_id=1038[...].apps.googleusercontent.com \
    --client_secret=VWFn8LIKAMC-MsjBMhJeOplZ \
    --generate_oauth2_token

The script will converse with Google and generate an oauth request
token, then present you with a URL you should visit in your browser to
authorize the token. Once you get the verification code from the Google
website, enter it into the script to get your OAuth access token. The output
from this command will contain the access token, a refresh token, and some
metadata about the tokens. The access token can be used until it expires, and
the refresh token lasts indefinitely, so you should record these values for
reuse.

2. The script will generate new access tokens using a refresh token.

  oauth2 --client_id=1038[...].apps.googleusercontent.com \
    --client_secret=VWFn8LIKAMC-MsjBMhJeOplZ \
    --refresh_token=1/Yzm6MRy4q1xi7Dx2DuWXNgT6s37OrP_DW_IoyTum4YA

see detail at: https://developers.google.com/gmail/imap/xoauth2-libraries
"""

import http.server
import io
import json
import logging
import optparse
import os
import select
import socketserver
import sys
import threading
import urllib.parse
import urllib.request

logging.basicConfig(
    format="\033[3;32m(%(levelname).1s) %(asctime)s <%(process)d> [%(filename)s:%(funcName)s:%(lineno)s]\033[0m %(message)s",
    level=logging.DEBUG,
    datefmt="%y-%m-%d %H:%M:%S",
)

# Hardcoded dummy redirect URI for non-web apps.
REDIRECT_URI = "urn:ietf:wg:oauth:2.0:oob"

# The URL root for accessing Google Accounts.
GOOGLE_ACCOUNTS_BASE_URL = "https://accounts.google.com"


def require_options(options: optparse.Values, *args: str):
    missing = [arg for arg in args if getattr(options, arg) is None]
    if missing:
        print("Missing options: %s" % " ".join(missing))
        sys.exit(-1)


def url_escape(text: str) -> str:
    # See OAUTH 5.1 for a definition of which characters need to be escaped.
    return urllib.parse.quote(text, safe="~-._")


def accounts_url(command: str):
    """Generates the Google Accounts URL.

    Args:
      command: The command to execute.

    Returns:
      A URL for the given command.
    """
    return "%s/%s" % (GOOGLE_ACCOUNTS_BASE_URL, command)


def format_url_params(params: dict[str, str]) -> str:
    """Formats parameters into a URL query string.

    Args:
      params: A key-value map.

    Returns:
      A URL query string version of the given parameters.
    """
    param_fragments = []
    for param in sorted(params.items(), key=lambda x: x[0]):
        param_fragments.append("%s=%s" % (param[0], url_escape(param[1])))
    return "&".join(param_fragments)


def generate_permission_url(
    client_id: str,
    redirect_uri: str,
    scope: str = "https://mail.google.com/",
) -> str:
    """Generates the URL for authorizing access.

    This uses the "OAuth2 for Installed Applications" flow described at
    https://developers.google.com/accounts/docs/OAuth2InstalledApp

    Args:
      client_id: Client ID obtained by registering your app.
      scope: scope for access token, e.g. 'https://mail.google.com'
    Returns:
      A URL that the user should visit in their browser.
    """
    params = {}
    params["client_id"] = client_id
    params["redirect_uri"] = redirect_uri
    params["scope"] = scope
    params["response_type"] = "code"
    return "%s?%s" % (accounts_url("o/oauth2/auth"), format_url_params(params))


def authorize_tokens(
    client_id: str,
    client_secret: str,
    redirect_uri: str,
    authorization_code: str,
) -> tuple[str, str, int] | None:
    """Obtains OAuth access token and refresh token.

    This uses the application portion of the "OAuth2 for Installed Applications"
    flow at https://developers.google.com/accounts/docs/OAuth2InstalledApp#handlingtheresponse

    Args:
      client_id: Client ID obtained by registering your app.
      client_secret: Client secret obtained by registering your app.
      authorization_code: code generated by Google Accounts after user grants
          permission.
    Returns:
      The decoded response from the Google Accounts server, as a tuple:
      (access_token, refresh_token, expires_in).
    """
    params = {}
    params["client_id"] = client_id
    params["client_secret"] = client_secret
    params["code"] = authorization_code
    params["redirect_uri"] = redirect_uri
    params["grant_type"] = "authorization_code"
    request_url = accounts_url("o/oauth2/token")

    try:
        response = urllib.request.urlopen(
            request_url, data=urllib.parse.urlencode(params).encode("utf8")
        ).read()
        res = json.loads(response)
        return res["access_token"], res["refresh_token"], res["expires_in"]
    except Exception as e:
        logging.error(e)
        return None


def refresh_token(
    client_id: str, client_secret: str, refresh_token: str
) -> tuple[str, int] | None:
    """Obtains a new token given a refresh token.

    See https://developers.google.com/accounts/docs/OAuth2InstalledApp#refresh

    Args:
      client_id: Client ID obtained by registering your app.
      client_secret: Client secret obtained by registering your app.
      refresh_token: A previously-obtained refresh token.
    Returns:
      The decoded response from the Google Accounts server, as a tuple:
      (access_token, expires_in).
    """
    params = {}
    params["client_id"] = client_id
    params["client_secret"] = client_secret
    params["refresh_token"] = refresh_token
    params["grant_type"] = "refresh_token"
    request_url = accounts_url("o/oauth2/token")

    try:
        response = urllib.request.urlopen(
            request_url, data=urllib.parse.urlencode(params).encode("utf8")
        ).read()
        res = json.loads(response)
        return res["access_token"], res["expires_in"]
    except Exception as e:
        logging.error(e)
        return None


class GetAuthCodeHandler(http.server.BaseHTTPRequestHandler):
    def __init__(
        self, opts: optparse.Values, redirect_uri: str, fd: int, *args, **kwargs
    ):
        self.opts = opts
        self.redirect_uri = redirect_uri
        self.fd = fd
        super().__init__(*args, **kwargs)

    def log_message(self, format, *args):
        pass

    def log_error(self, format, *args):
        pass

    def log_request(self, code="-", size="-"):
        pass

    def do_GET(self):
        query = self.path
        if "?" in query:
            _, query = query.split("?", 1)
        qs = urllib.parse.parse_qs(query)

        [authorization_code] = qs.get("code", ["None"])
        # os.write(self.fd, f"{authorization_code}\n".encode("utf8"))

        res_json = {}
        response = authorize_tokens(
            opts.client_id,
            opts.client_secret,
            self.redirect_uri,
            authorization_code,
        )

        if response is None:
            res_json["message"] = "query fail"
        else:
            access_token, refr_token, expires_in = response
            res_json["Refresh Token"] = refr_token
            res_json["Access Token"] = access_token
            res_json["Access Token Expiration Seconds"] = expires_in

        self.send_response(200, "OK")
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps(res_json).encode("utf8"))


def handle_authorize_tokens_redirect(
    opts: optparse.Values, redirect_uri: str, pipe_write: int
):
    socketserver.TCPServer.allow_reuse_address = True
    httpd = socketserver.TCPServer(
        ("", opts.redirect_port),
        lambda *_: GetAuthCodeHandler(opts, redirect_uri, pipe_write, *_),
    )
    httpd.handle_request()
    os.write(pipe_write, b".")


def get_authorize_tokens(opts: optparse.Values):
    redirect_uri = f"http://{opts.redirect_ip}:{opts.redirect_port}"
    require_options(opts, "client_id", "client_secret")
    permission_url = generate_permission_url(
        opts.client_id,
        redirect_uri,
        opts.scope,
    )

    pipe_read, pipe_write = os.pipe()
    # sys.stdin = io.FileIO(pipe_read)
    t = threading.Thread(
        target=handle_authorize_tokens_redirect,
        args=(
            opts,
            redirect_uri,
            pipe_write,
        ),
    )
    t.daemon = True
    t.start()

    print("To authorize token, visit this url and follow the directions:")
    print(f"    {permission_url}")
    sys.stdout.write("Enter verification code: ")
    sys.stdout.flush()

    readable, _, _ = select.select([sys.stdin, pipe_read], [], [])
    if pipe_read in readable:
        return

    authorization_code = sys.stdin.readline()
    response = authorize_tokens(
        opts.client_id,
        opts.client_secret,
        redirect_uri,
        authorization_code,
    )
    if response is None:
        sys.exit(-1)
    access_token, refr_token, expires_in = response
    print(f"Refresh Token: {refr_token}")
    print(f"Access Token: {access_token}")
    print(f"Access Token Expiration Seconds: {expires_in}")


if __name__ == "__main__":
    parser = optparse.OptionParser(usage=__doc__)
    parser.add_option(
        "--generate_oauth2_token",
        action="store_true",
        dest="generate_oauth2_token",
        help="generates an OAuth2 token for testing",
    )
    parser.add_option(
        "--refresh_token", default=None, help="OAuth2 refresh token"
    )
    parser.add_option(
        "--client_id",
        type=str,
        dest="client_id",
        help="Client ID of the application that is authenticating. "
        "See OAuth2 documentation for details.",
    )
    parser.add_option(
        "--client_secret",
        type=str,
        dest="client_secret",
        help="Client secret of the application that is authenticating. "
        "See OAuth2 documentation for details.",
    )
    parser.add_option(
        "--scope",
        type=str,
        dest="scope",
        default="https://mail.google.com/",
        help="scope for the access token. Multiple scopes can be listed "
        "separated by spaces with the whole argument quoted.",
    )
    parser.add_option(
        "--redirect_ip",
        type=str,
        dest="redirect_ip",
        default="127.0.0.1",
        help="determines the IP how Google's authorization server sends a response",
    )
    parser.add_option(
        "--redirect_port",
        type=int,
        dest="redirect_port",
        default=8080,
        help="determines the port how Google's authorization server sends a response",
    )
    opts, _ = parser.parse_args()

    if opts.generate_oauth2_token:
        get_authorize_tokens(opts)
    elif opts.refresh_token:
        require_options(opts, "client_id", "client_secret")
        response = refresh_token(
            opts.client_id, opts.client_secret, opts.refresh_token
        )
        if response is None:
            sys.exit(-1)
        access_token, expires_in = response
        print(f"Access Token: {access_token}")
        print(f"Access Token Expiration Seconds: {expires_in}")
